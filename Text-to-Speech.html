<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text to Speech - Your Multi Tools</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
<style>
:root {
--dark-bg: #121212;
--dark-card: #1e1e1e;
--dark-text: #f0f0f0;
--dark-accent: #4361ee;
--dark-secondary: #4cc9f0;
--dark-hover: #2a2a2a;
--dark-shadow: rgba(0, 0, 0, 0.5);
--light-bg: #f8f9fa;
--light-card: #ffffff;
--light-text: #333333;
--light-accent: #4361ee;
--light-secondary: #3a86ff;
--light-hover: #f0f0f0;
--light-shadow: rgba(0, 0, 0, 0.1);
}
* {
margin: 0;
padding: 0;
box-sizing: border-box;
transition: background-color 0.5s ease, color 0.3s ease;
}
body {
font-family: 'Poppins', sans-serif;
background-color: var(--dark-bg);
color: var(--dark-text);
min-height: 100vh;
overflow-x: hidden;
position: relative;
}
body.light-mode {
background-color: var(--light-bg);
color: var(--light-text);
}
/* Particles background */
.particles {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
z-index: -1;
overflow: hidden;
}
.particle {
position: absolute;
border-radius: 50%;
background: rgba(67, 97, 238, 0.2);
animation: float 15s infinite linear;
}
@keyframes float {
0% {
transform: translateY(0) translateX(0) rotate(0deg);
opacity: 1;
}
100% {
transform: translateY(-100vh) translateX(100px) rotate(360deg);
opacity: 0;
}
}
.container {
max-width: 1200px;
margin: 0 auto;
padding: 20px;
}
/* Header Styles */
header {
display: flex;
justify-content: space-between;
align-items: center;
padding: 25px 20px;
position: relative;
z-index: 10;
flex-wrap: wrap;
}
.logo {
display: flex;
align-items: center;
gap: 15px;
}
.logo-icon {
font-size: 2.5rem;
color: var(--dark-secondary);
}
.logo-text {
display: flex;
flex-direction: column;
}
.logo-text h1 {
font-family: 'Orbitron', sans-serif;
font-size: 2rem;
font-weight: 700;
background: linear-gradient(45deg, var(--dark-secondary), var(--dark-accent));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
letter-spacing: 1px;
}
.logo-text .domain {
font-size: 0.9rem;
color: var(--dark-text);
opacity: 0.8;
letter-spacing: 1px;
}
.light-mode .logo-text .domain {
color: var(--light-text);
}
/* Theme Toggle */
.theme-toggle {
display: flex;
align-items: center;
gap: 10px;
background: var(--dark-card);
padding: 8px 15px;
border-radius: 50px;
cursor: pointer;
user-select: none;
box-shadow: 0 4px 15px var(--dark-shadow);
}
.light-mode .theme-toggle {
background: var(--light-card);
box-shadow: 0 4px 15px var(--light-shadow);
}
.toggle-icon {
font-size: 1.4rem;
}
.toggle-text {
font-weight: 500;
}
/* Main Content */
.main-content {
display: flex;
flex-direction: column;
align-items: center;
padding: 40px 20px;
}
.main-content h2 {
font-size: 2.8rem;
margin-bottom: 15px;
background: linear-gradient(45deg, var(--dark-secondary), var(--dark-accent));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
font-family: 'Orbitron', sans-serif;
text-align: center;
}
.light-mode .main-content h2 {
background: linear-gradient(45deg, var(--light-secondary), var(--light-accent));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
}
.main-content p {
font-size: 1.2rem;
line-height: 1.7;
text-align: center;
max-width: 800px;
margin-bottom: 40px;
color: var(--dark-text);
opacity: 0.9;
}
.light-mode .main-content p {
color: var(--light-text);
}
/* Text Input Area */
.text-input-container {
width: 100%;
max-width: 800px;
margin-bottom: 30px;
}
.text-area {
width: 100%;
height: 200px;
padding: 20px;
border-radius: 15px;
border: 3px solid var(--dark-accent);
background: var(--dark-card);
color: var(--dark-text);
font-size: 1rem;
font-family: 'Poppins', sans-serif;
resize: none;
box-shadow: 0 8px 25px var(--dark-shadow);
transition: all 0.3s ease;
}
.light-mode .text-area {
background: var(--light-card);
border-color: var(--light-accent);
color: var(--light-text);
box-shadow: 0 8px 25px var(--light-shadow);
}
.text-area:focus {
outline: none;
border-color: var(--dark-secondary);
box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.3);
}
.light-mode .text-area:focus {
border-color: var(--light-secondary);
box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
}
/* Controls */
.controls-container {
width: 100%;
max-width: 800px;
background: var(--dark-card);
border-radius: 15px;
padding: 25px;
box-shadow: 0 8px 25px var(--dark-shadow);
margin-bottom: 30px;
border: 1px solid rgba(76, 201, 240, 0.1);
}
.light-mode .controls-container {
background: var(--light-card);
box-shadow: 0 8px 25px var(--light-shadow);
border: 1px solid rgba(0, 0, 0, 0.05);
}
.controls-row {
display: flex;
flex-wrap: wrap;
gap: 20px;
margin-bottom: 20px;
}
.controls-row:last-child {
margin-bottom: 0;
}
.control-group {
flex: 1;
min-width: 200px;
}
.control-group label {
display: block;
margin-bottom: 8px;
font-weight: 500;
font-size: 1rem;
}
.control-group select, .control-group input[type="range"] {
width: 100%;
padding: 10px;
border-radius: 8px;
border: 1px solid rgba(76, 201, 240, 0.3);
background: rgba(30, 30, 30, 0.7);
color: var(--dark-text);
font-size: 1rem;
}
.light-mode .control-group select, .light-mode .control-group input[type="range"] {
background: rgba(255, 255, 255, 0.7);
color: var(--light-text);
border: 1px solid rgba(67, 97, 238, 0.3);
}
.control-group input[type="range"] {
-webkit-appearance: none;
height: 8px;
background: rgba(67, 97, 238, 0.3);
border: none;
border-radius: 4px;
}
.control-group input[type="range"]::-webkit-slider-thumb {
-webkit-appearance: none;
width: 20px;
height: 20px;
border-radius: 50%;
background: var(--dark-accent);
cursor: pointer;
}
.light-mode .control-group input[type="range"]::-webkit-slider-thumb {
background: var(--light-accent);
}
/* Voice Presets */
.presets-container {
width: 100%;
max-width: 800px;
margin-bottom: 30px;
}
.presets-title {
font-size: 1.3rem;
margin-bottom: 15px;
font-weight: 600;
color: var(--dark-secondary);
}
.light-mode .presets-title {
color: var(--light-secondary);
}
.presets-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
gap: 15px;
}
.preset-btn {
background: rgba(30, 30, 30, 0.7);
border: 1px solid rgba(76, 201, 240, 0.3);
border-radius: 10px;
padding: 15px;
text-align: center;
cursor: pointer;
transition: all 0.3s ease;
color: var(--dark-text);
}
.light-mode .preset-btn {
background: rgba(255, 255, 255, 0.7);
border-color: rgba(67, 97, 238, 0.3);
color: var(--light-text);
}
.preset-btn:hover {
background: rgba(67, 97, 238, 0.2);
transform: translateY(-3px);
}
.preset-btn.active {
background: var(--dark-accent);
color: white;
border-color: var(--dark-accent);
}
.light-mode .preset-btn.active {
background: var(--light-accent);
border-color: var(--light-accent);
}
.preset-btn i {
font-size: 1.5rem;
margin-bottom: 8px;
color: var(--dark-secondary);
}
.light-mode .preset-btn i {
color: var(--light-secondary);
}
/* Playback Controls */
.playback-container {
width: 100%;
max-width: 800px;
display: flex;
justify-content: center;
align-items: center;
gap: 20px;
margin-bottom: 30px;
flex-wrap: wrap;
}
.playback-btn {
display: inline-flex;
align-items: center;
justify-content: center;
width: 60px;
height: 60px;
border-radius: 50%;
background: var(--dark-card);
color: var(--dark-secondary);
font-size: 1.5rem;
cursor: pointer;
transition: all 0.3s ease;
border: 2px solid rgba(76, 201, 240, 0.3);
}
.light-mode .playback-btn {
background: var(--light-card);
color: var(--light-secondary);
border-color: rgba(67, 97, 238, 0.3);
}
.playback-btn:hover {
background: var(--dark-accent);
color: white;
transform: scale(1.1);
}
.playback-btn:disabled {
opacity: 0.5;
cursor: not-allowed;
transform: none;
}
/* Download Button */
.download-container {
display: flex;
flex-direction: column;
align-items: center;
width: 100%;
max-width: 800px;
}
.download-btn {
display: inline-flex;
align-items: center;
gap: 12px;
padding: 15px 30px;
background: linear-gradient(45deg, var(--dark-accent), var(--dark-secondary));
color: white;
text-decoration: none;
border-radius: 50px;
font-weight: 600;
font-size: 1.1rem;
transition: all 0.3s ease;
box-shadow: 0 5px 15px rgba(67, 97, 238, 0.4);
cursor: pointer;
}
.light-mode .download-btn {
background: linear-gradient(45deg, var(--light-accent), var(--light-secondary));
box-shadow: 0 5px 15px rgba(67, 97, 238, 0.2);
}
.download-btn:hover {
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(67, 97, 238, 0.5);
gap: 15px;
}
.download-btn:disabled {
opacity: 0.6;
cursor: not-allowed;
transform: none;
}
/* Audio Format Selection */
.format-selection {
margin-top: 15px;
display: flex;
flex-direction: column;
gap: 10px;
width: 100%;
max-width: 600px;
}
.format-selection-header {
display: flex;
align-items: center;
justify-content: space-between;
width: 100%;
}
.format-selection-header h3 {
margin: 0;
font-size: 1.1rem;
color: var(--dark-secondary);
}
.format-selection-header .format-info {
font-size: 0.9rem;
color: var(--dark-text);
opacity: 0.8;
}
.light-mode .format-selection-header h3 {
color: var(--light-secondary);
}
.light-mode .format-selection-header .format-info {
color: var(--light-text);
}
.format-selection-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
gap: 10px;
width: 100%;
}
.format-option {
background: rgba(30, 30, 30, 0.7);
border: 1px solid rgba(76, 201, 240, 0.3);
border-radius: 8px;
padding: 12px;
cursor: pointer;
transition: all 0.3s ease;
display: flex;
flex-direction: column;
align-items: center;
gap: 8px;
}
.light-mode .format-option {
background: rgba(255, 255, 255, 0.7);
border-color: rgba(67, 97, 238, 0.3);
}
.format-option:hover {
background: rgba(67, 97, 238, 0.2);
transform: translateY(-2px);
}
.format-option.active {
background: var(--dark-accent);
color: white;
border-color: var(--dark-accent);
}
.light-mode .format-option.active {
background: var(--light-accent);
border-color: var(--light-accent);
}
.format-option i {
font-size: 1.2rem;
color: var(--dark-secondary);
}
.light-mode .format-option i {
color: var(--light-secondary);
}
.format-option-name {
font-weight: 500;
font-size: 0.9rem;
text-align: center;
}
.format-option-desc {
font-size: 0.8rem;
opacity: 0.8;
text-align: center;
}
.quality-options {
display: flex;
flex-wrap: wrap;
gap: 10px;
width: 100%;
margin-top: 10px;
}
.quality-option {
flex: 1;
min-width: 120px;
background: rgba(30, 30, 30, 0.7);
border: 1px solid rgba(76, 201, 240, 0.3);
border-radius: 8px;
padding: 10px;
cursor: pointer;
transition: all 0.3s ease;
text-align: center;
}
.light-mode .quality-option {
background: rgba(255, 255, 255, 0.7);
border-color: rgba(67, 97, 238, 0.3);
}
.quality-option:hover {
background: rgba(67, 97, 238, 0.2);
}
.quality-option.active {
background: var(--dark-accent);
color: white;
border-color: var(--dark-accent);
}
.light-mode .quality-option.active {
background: var(--light-accent);
border-color: var(--light-accent);
}
.quality-option-name {
font-weight: 500;
font-size: 0.9rem;
}
.quality-option-info {
font-size: 0.8rem;
opacity: 0.8;
}
/* File Size Display */
.file-size-display {
margin-top: 10px;
font-size: 0.9rem;
color: var(--dark-text);
opacity: 0.8;
text-align: center;
}
.light-mode .file-size-display {
color: var(--light-text);
}
/* Footer */
footer {
text-align: center;
padding: 60px 20px 40px;
color: var(--dark-text);
opacity: 0.7;
font-size: 1.1rem;
border-top: 1px solid rgba(255, 255, 255, 0.1);
margin-top: 30px;
}
.light-mode footer {
color: var(--light-text);
border-top: 1px solid rgba(0, 0, 0, 0.1);
}
.footer-logo {
font-family: 'Orbitron', sans-serif;
font-size: 2rem;
font-weight: 700;
margin-bottom: 20px;
background: linear-gradient(45deg, var(--dark-secondary), var(--dark-accent));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
letter-spacing: 1px;
}
.light-mode .footer-logo {
background: linear-gradient(45deg, var(--light-secondary), var(--light-accent));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
}
.footer-links {
display: flex;
justify-content: center;
gap: 30px;
margin-bottom: 25px;
flex-wrap: wrap;
}
.footer-links a {
color: var(--dark-text);
text-decoration: none;
transition: color 0.3s ease;
opacity: 0.8;
}
.light-mode .footer-links a {
color: var(--light-text);
}
.footer-links a:hover {
color: var(--dark-secondary);
opacity: 1;
}
.light-mode .footer-links a:hover {
color: var(--light-secondary);
}
.copyright {
margin-top: 20px;
font-size: 0.95rem;
}
/* Notification */
.notification {
position: fixed;
top: 20px;
right: 20px;
background: var(--dark-card);
color: var(--dark-text);
padding: 15px 25px;
border-radius: 10px;
box-shadow: 0 5px 15px rgba(0,0,0,0.3);
transform: translateX(120%);
transition: transform 0.3s ease;
z-index: 1000;
display: flex;
align-items: center;
gap: 10px;
}
.notification.show {
transform: translateX(0);
}
.light-mode .notification {
background: var(--light-card);
color: var(--light-text);
box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}
/* Responsive Design */
@media (max-width: 992px) {
.main-content h2 {
font-size: 2.5rem;
}
}
@media (max-width: 768px) {
.main-content h2 {
font-size: 2rem;
}
.controls-row {
flex-direction: column;
gap: 15px;
}
.playback-container {
flex-direction: column;
}
}
@media (max-width: 576px) {
header {
flex-direction: column;
gap: 20px;
text-align: center;
}
.logo-text h1 {
font-size: 1.6rem;
}
.main-content h2 {
font-size: 1.8rem;
}
.drop-area {
padding: 30px 15px;
}
.drop-area h3 {
font-size: 1.5rem;
}
.drop-area p {
font-size: 1rem;
}
}
</style>
</head>
<body>
<div class="particles" id="particles"></div>
<div class="notification" id="notification">
<i class="fas fa-check-circle"></i>
<span id="notification-text">Text converted to speech successfully!</span>
</div>
<div class="container">
<header>
<div class="logo">
<i class="fas fa-tools logo-icon"></i>
<div class="logo-text">
<h1>Your Multi Tools</h1>
<div class="domain">www.yourmultitools.space</div>
</div>
</div>
<div class="theme-toggle" id="themeToggle">
<i class="fa-moon toggle-icon"></i>
<div class="toggle-text">Dark Mode</div>
</div>
</header>
<section class="main-content">
<h2>Text to Speech</h2>
<p>Convert written text into natural-sounding audio with human-like voices in 50+ languages and accents. Adjust speech rate, pitch, and volume for customized listening experiences.</p>
<div class="text-input-container">
<textarea class="text-area" id="textInput" placeholder="Enter the text you want to convert to speech..."></textarea>
</div>
<div class="controls-container">
<div class="controls-row">
<div class="control-group">
<label for="voiceSelect">Voice</label>
<select id="voiceSelect">
<option value="">Loading voices...</option>
</select>
</div>
<div class="control-group">
<label for="languageSelect">Language</label>
<select id="languageSelect">
<option value="">Select language</option>
<option value="en-US">English (US)</option>
<option value="en-GB">English (UK)</option>
<option value="en-AU">English (Australia)</option>
<option value="en-CA">English (Canada)</option>
<option value="en-IN">English (India)</option>
<option value="hi-IN">Hindi</option>
<option value="bn-IN">Bengali</option>
<option value="mr-IN">Marathi</option>
<option value="ta-IN">Tamil</option>
<option value="te-IN">Telugu</option>
<option value="ml-IN">Malayalam</option>
<option value="gu-IN">Gujarati</option>
<option value="kn-IN">Kannada</option>
<option value="pa-IN">Punjabi</option>
<option value="ur-PK">Urdu</option>
<option value="or-IN">Odia</option>
<option value="as-IN">Assamese</option>
<option value="ml-IN">Malayalam</option>
<option value="sa-IN">Sanskrit</option>
<option value="ks-IN">Kashmiri</option>
<option value="sd-IN">Sindhi</option>
<option value="ne-NP">Nepali</option>
<option value="gom-IN">Konkani</option>
<option value="mai-IN">Maithili</option>
<option value="sat-IN">Santali</option>
<option value="bn-IN">Bengali</option>
<option value="ta-IN">Tamil</option>
<option value="te-IN">Telugu</option>
<option value="kn-IN">Kannada</option>
<option value="ml-IN">Malayalam</option>
<option value="mr-IN">Marathi</option>
<option value="gu-IN">Gujarati</option>
<option value="pa-IN">Punjabi</option>
<option value="ur-PK">Urdu</option>
<option value="zh-CN">Mandarin Chinese</option>
<option value="zh-TW">Chinese (Traditional)</option>
<option value="es-ES">Spanish</option>
<option value="es-MX">Spanish (Mexico)</option>
<option value="fr-FR">French</option>
<option value="fr-CA">French (Canada)</option>
<option value="ar-SA">Arabic</option>
<option value="ru-RU">Russian</option>
<option value="pt-PT">Portuguese</option>
<option value="pt-BR">Portuguese (Brazil)</option>
<option value="ja-JP">Japanese</option>
<option value="de-DE">German</option>
<option value="sw-KE">Swahili</option>
<option value="it-IT">Italian</option>
<option value="ko-KR">Korean</option>
<option value="vi-VN">Vietnamese</option>
<option value="tr-TR">Turkish</option>
</select>
</div>
</div>
<div class="controls-row">
<div class="control-group">
<label for="rateSlider">Rate: <span id="rateValue">1.0</span></label>
<input type="range" id="rateSlider" min="0.5" max="2" step="0.1" value="1">
</div>
<div class="control-group">
<label for="pitchSlider">Pitch: <span id="pitchValue">1.0</span></label>
<input type="range" id="pitchSlider" min="0.5" max="2" step="0.1" value="1">
</div>
<div class="control-group">
<label for="volumeSlider">Volume: <span id="volumeValue">1.0</span></label>
<input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1">
</div>
</div>
</div>
<div class="presets-container">
<div class="presets-title">Voice Presets</div>
<div class="presets-grid">
<div class="preset-btn" data-preset="narration">
<i class="fas fa-book"></i>
Narration
</div>
<div class="preset-btn" data-preset="announcement">
<i class="fas fa-bullhorn"></i>
Announcement
</div>
<div class="preset-btn" data-preset="conversational">
<i class="fas fa-comments"></i>
Conversational
</div>
<div class="preset-btn" data-preset="storytelling">
<i class="fas fa-book-open"></i>
Storytelling
</div>
</div>
</div>
<div class="playback-container">
<div class="playback-btn" id="playBtn">
<i class="fas fa-play"></i>
</div>
<div class="playback-btn" id="pauseBtn" disabled>
<i class="fas fa-pause"></i>
</div>
<div class="playback-btn" id="stopBtn" disabled>
<i class="fas fa-stop"></i>
</div>
</div>
<div class="download-container">
<a class="download-btn" id="downloadBtn" disabled>
<i class="fas fa-download"></i>
Download Audio
</a>
<div class="format-selection">
<div class="format-selection-header">
<h3>Audio Format</h3>
<div class="format-info" id="formatInfo">Select format for download</div>
</div>
<div class="format-selection-grid">
<div class="format-option active" data-format="wav">
<i class="fas fa-wave-square"></i>
<div class="format-option-name">WAV</div>
<div class="format-option-desc">Lossless</div>
</div>
<div class="format-option" data-format="flac">
<i class="fas fa-file-audio"></i>
<div class="format-option-name">FLAC</div>
<div class="format-option-desc">Lossless</div>
</div>
<div class="format-option" data-format="mp3">
<i class="fas fa-music"></i>
<div class="format-option-name">MP3</div>
<div class="format-option-desc">Compressed</div>
</div>
<div class="format-option" data-format="ogg">
<i class="fas fa-code"></i>
<div class="format-option-name">OGG</div>
<div class="format-option-desc">Open Source</div>
</div>
<div class="format-option" data-format="m4a">
<i class="fab fa-apple"></i>
<div class="format-option-name">M4A</div>
<div class="format-option-desc">Apple</div>
</div>
<div class="format-option" data-format="aac">
<i class="fas fa-play-circle"></i>
<div class="format-option-name">AAC</div>
<div class="format-option-desc">Streaming</div>
</div>
</div>
<div class="quality-options">
<div class="quality-option active" data-quality="high">
<div class="quality-option-name">High Quality</div>
<div class="quality-option-info">Best sound quality</div>
</div>
<div class="quality-option" data-quality="medium">
<div class="quality-option-name">Medium Quality</div>
<div class="quality-option-info">Balanced size/quality</div>
</div>
<div class="quality-option" data-quality="low">
<div class="quality-option-name">Low Quality</div>
<div class="quality-option-info">Smaller file size</div>
</div>
</div>
<div class="file-size-display" id="fileSizeDisplay">Estimated file size: 0 KB</div>
</div>
</div>
<section class="main-content">
<h2>Audio Format Information</h2>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 20px;">
<div style="background: var(--dark-card); padding: 15px; border-radius: 10px; border: 1px solid rgba(76, 201, 240, 0.1);">
<h3 style="color: var(--dark-secondary); margin-bottom: 10px;"><i class="fas fa-wave-square"></i> WAV</h3>
<p style="font-size: 0.9rem; color: var(--dark-text); opacity: 0.9;">Uncompressed audio format that preserves 100% of original sound quality. Ideal for professional editing and high-fidelity applications. Large file sizes but excellent quality.</p>
</div>
<div style="background: var(--dark-card); padding: 15px; border-radius: 10px; border: 1px solid rgba(76, 201, 240, 0.1);">
<h3 style="color: var(--dark-secondary); margin-bottom: 10px;"><i class="fas fa-file-audio"></i> FLAC</h3>
<p style="font-size: 0.9rem; color: var(--dark-text); opacity: 0.9;">Lossless compression format that reduces file size by 50-70% without quality loss. Perfect for archiving and high-fidelity audio collections. Supported by most modern players.</p>
</div>
<div style="background: var(--dark-card); padding: 15px; border-radius: 10px; border: 1px solid rgba(76, 201, 240, 0.1);">
<h3 style="color: var(--dark-secondary); margin-bottom: 10px;"><i class="fas fa-music"></i> MP3</h3>
<p style="font-size: 0.9rem; color: var(--dark-text); opacity: 0.9;">Widely supported lossy format with good compression. Choose from 128kbps (standard) to 320kbps (near-CD quality). Ideal for music and podcasts. Universally compatible.</p>
</div>
<div style="background: var(--dark-card); padding: 15px; border-radius: 10px; border: 1px solid rgba(76, 201, 240, 0.1);">
<h3 style="color: var(--dark-secondary); margin-bottom: 10px;"><i class="fas fa-play-circle"></i> AAC</h3>
<p style="font-size: 0.9rem; color: var(--dark-text); opacity: 0.9;">Advanced Audio Coding offers better quality than MP3 at the same bitrate. Preferred for streaming services and mobile devices. Excellent for podcasts and video content.</p>
</div>
<div style="background: var(--dark-card); padding: 15px; border-radius: 10px; border: 1px solid rgba(76, 201, 240, 0.1);">
<h3 style="color: var(--dark-secondary); margin-bottom: 10px;"><i class="fab fa-apple"></i> M4A</h3>
<p style="font-size: 0.9rem; color: var(--dark-text); opacity: 0.9;">Apple's preferred format using AAC encoding. Excellent compression with good quality. Ideal for iTunes, Apple devices, and video content. Smaller than MP3 at similar quality.</p>
</div>
<div style="background: var(--dark-card); padding: 15px; border-radius: 10px; border: 1px solid rgba(76, 201, 240, 0.1);">
<h3 style="color: var(--dark-secondary); margin-bottom: 10px;"><i class="fas fa-code"></i> OGG</h3>
<p style="font-size: 0.9rem; color: var(--dark-text); opacity: 0.9;">Open-source, royalty-free format with better compression than MP3. Supports multiple channels and high bitrates. Popular for gaming and web applications. Not supported by some older devices.</p>
</div>
</div>
</section>

</div>
<script>
// Create floating particles
function createParticles() {
    const particlesContainer = document.getElementById('particles');
    const particleCount = 50;
    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.classList.add('particle');
        // Random size
        const size = Math.random() * 20 + 5;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        // Random position
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        // Random animation duration
        const duration = Math.random() * 20 + 10;
        particle.style.animationDuration = `${duration}s`;
        // Random animation delay
        const delay = Math.random() * 5;
        particle.style.animationDelay = `${delay}s`;
        particlesContainer.appendChild(particle);
    }
}
// Theme Toggle Functionality
const themeToggle = document.getElementById('themeToggle');
const body = document.body;
const toggleIcon = themeToggle.querySelector('.toggle-icon');
const toggleText = themeToggle.querySelector('.toggle-text');
// Check for saved theme preference
const savedTheme = localStorage.getItem('theme');
if (savedTheme === 'light') {
    body.classList.add('light-mode');
    toggleIcon.classList.replace('fa-moon', 'fa-sun');
    toggleText.textContent = 'Light Mode';
}
themeToggle.addEventListener('click', () => {
    body.classList.toggle('light-mode');
    if (body.classList.contains('light-mode')) {
        toggleIcon.classList.replace('fa-moon', 'fa-sun');
        toggleText.textContent = 'Light Mode';
        localStorage.setItem('theme', 'light');
    } else {
        toggleIcon.classList.replace('fa-sun', 'fa-moon');
        toggleText.textContent = 'Dark Mode';
        localStorage.setItem('theme', 'dark');
    }
});
// Text-to-Speech Functionality
const textInput = document.getElementById('textInput');
const voiceSelect = document.getElementById('voiceSelect');
const languageSelect = document.getElementById('languageSelect');
const rateSlider = document.getElementById('rateSlider');
const pitchSlider = document.getElementById('pitchSlider');
const volumeSlider = document.getElementById('volumeSlider');
const rateValue = document.getElementById('rateValue');
const pitchValue = document.getElementById('pitchValue');
const volumeValue = document.getElementById('volumeValue');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const downloadBtn = document.getElementById('downloadBtn');
const formatSelect = document.getElementById('formatSelect');
const qualityOptions = document.querySelectorAll('.quality-option');
const formatOptions = document.querySelectorAll('.format-option');
const fileSizeDisplay = document.getElementById('fileSizeDisplay');
const formatInfo = document.getElementById('formatInfo');
const presetBtns = document.querySelectorAll('.preset-btn');
const notification = document.getElementById('notification');
const notificationText = document.getElementById('notification-text');
let speechSynthesis = window.speechSynthesis;
let voices = [];
let currentUtterance = null;
let audioContext = null;
let audioBuffer = null;
let audioChunks = [];
let mediaRecorder = null;
let audioBlob = null;
let selectedFormat = 'wav';
let selectedQuality = 'high';
let audioLength = 0;
let audioStream = null;
// Load available voices with proper initialization
function loadVoices() {
    voices = speechSynthesis.getVoices();
    
    // Clear existing options
    voiceSelect.innerHTML = '';
    
    // Add default option if no voices available
    if (voices.length === 0) {
        const option = document.createElement('option');
        option.value = "";
        option.textContent = "No voices available";
        voiceSelect.appendChild(option);
        showNotification('No speech synthesis voices found in your browser', 'error');
        return;
    }
    
    // Sort voices by language and name
    voices.sort((a, b) => {
        // First sort by language
        const langA = a.lang.split('-')[0];
        const langB = b.lang.split('-')[0];
        if (langA !== langB) return langA.localeCompare(langB);
        
        // Then sort by name
        return a.name.localeCompare(b.name);
    });
    
    // Add voice options
    voices.forEach((voice, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = `${voice.name} (${voice.lang})`;
        voiceSelect.appendChild(option);
    });
    
    // Set default voice if available
    if (voices.length > 0) {
        voiceSelect.value = "0"; // Select first voice
    }
}
// Initialize voices
if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = loadVoices;
}
// Check if speech synthesis is supported
if (!speechSynthesis) {
    showNotification('Text-to-Speech is not supported in your browser', 'error');
    playBtn.disabled = true;
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
    downloadBtn.disabled = true;
} else {
    // Try to load voices immediately
    loadVoices();
    
    // Also try to load voices after a short delay (for some browsers)
    setTimeout(loadVoices, 1000);
}
// Update slider value displays
rateSlider.addEventListener('input', () => {
    rateValue.textContent = rateSlider.value;
});
pitchSlider.addEventListener('input', () => {
    pitchValue.textContent = pitchSlider.value;
});
volumeSlider.addEventListener('input', () => {
    volumeValue.textContent = volumeSlider.value;
});
// Format selection
formatOptions.forEach(option => {
    option.addEventListener('click', () => {
        formatOptions.forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        selectedFormat = option.dataset.format;
        updateFormatInfo();
        updateFileSizeEstimate();
    });
});
// Quality selection
qualityOptions.forEach(option => {
    option.addEventListener('click', () => {
        qualityOptions.forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        selectedQuality = option.dataset.quality;
        updateFileSizeEstimate();
    });
});
// Update format information
function updateFormatInfo() {
    const formatData = {
        wav: { name: 'WAV', desc: 'Uncompressed, CD-quality audio' },
        flac: { name: 'FLAC', desc: 'Lossless compression, high quality' },
        mp3: { name: 'MP3', desc: 'Compressed, widely compatible' },
        ogg: { name: 'OGG', desc: 'Open source, good compression' },
        m4a: { name: 'M4A', desc: 'Apple format, AAC encoded' },
        aac: { name: 'AAC', desc: 'Advanced Audio Coding, streaming' }
    };
    
    const info = formatData[selectedFormat] || formatData.wav;
    formatInfo.textContent = `${info.name}: ${info.desc}`;
}
// Update file size estimate
function updateFileSizeEstimate() {
    if (audioLength === 0) {
        fileSizeDisplay.textContent = 'Estimated file size: 0 KB';
        return;
    }
    
    // Base file size calculation (1 minute = ~1MB for WAV)
    let baseSize = audioLength * 1000; // KB
    
    // Apply compression ratios based on format and quality
    let compressionRatio = 1.0;
    
    switch (selectedFormat) {
        case 'flac':
            compressionRatio = 0.5; // 50% compression
            break;
        case 'mp3':
            if (selectedQuality === 'high') compressionRatio = 0.3;
            else if (selectedQuality === 'medium') compressionRatio = 0.4;
            else compressionRatio = 0.6;
            break;
        case 'ogg':
            if (selectedQuality === 'high') compressionRatio = 0.25;
            else if (selectedQuality === 'medium') compressionRatio = 0.35;
            else compressionRatio = 0.5;
            break;
        case 'm4a':
            if (selectedQuality === 'high') compressionRatio = 0.3;
            else if (selectedQuality === 'medium') compressionRatio = 0.4;
            else compressionRatio = 0.6;
            break;
        case 'aac':
            if (selectedQuality === 'high') compressionRatio = 0.35;
            else if (selectedQuality === 'medium') compressionRatio = 0.45;
            else compressionRatio = 0.65;
            break;
    }
    
    const estimatedSize = Math.round(baseSize * compressionRatio);
    const sizeUnit = estimatedSize > 1024 ? 'MB' : 'KB';
    const sizeValue = estimatedSize > 1024 ? (estimatedSize / 1024).toFixed(2) : estimatedSize;
    
    fileSizeDisplay.textContent = `Estimated file size: ${sizeValue} ${sizeUnit}`;
}
// Play speech
playBtn.addEventListener('click', () => {
    if (!textInput.value.trim()) {
        showNotification('Please enter some text to convert', 'error');
        return;
    }
    if (currentUtterance) {
        speechSynthesis.cancel();
    }
    // Initialize audio context if needed
    if (!audioContext) {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.error('AudioContext not supported:', e);
            showNotification('Your browser does not support audio recording', 'error');
            setupSimpleDownload();
            return;
        }
    }
    currentUtterance = new SpeechSynthesisUtterance(textInput.value);
    const selectedVoiceIndex = voiceSelect.value;
    if (selectedVoiceIndex && voices[selectedVoiceIndex]) {
        currentUtterance.voice = voices[selectedVoiceIndex];
    }
    currentUtterance.rate = parseFloat(rateSlider.value);
    currentUtterance.pitch = parseFloat(pitchSlider.value);
    currentUtterance.volume = parseFloat(volumeSlider.value);
    // Estimate audio length (average speaking rate: 150 words per minute)
    const wordCount = textInput.value.trim().split(/\s+/).length;
    audioLength = wordCount / 150 * 60; // Convert to seconds
    updateFileSizeEstimate();
    // Create audio stream from speech
    const audioDestination = audioContext.createMediaStreamDestination();
    const audioSource = audioContext.createMediaStreamDestination();
    
    // Connect speech to audio processing
    const speechProcessor = audioContext.createScriptProcessor(4096, 1, 1);
    speechProcessor.onaudioprocess = (event) => {
        const inputData = event.inputBuffer.getChannelData(0);
        const outputData = event.outputBuffer.getChannelData(0);
        for (let i = 0; i < inputData.length; i++) {
            outputData[i] = inputData[i];
        }
    };
    
    // Start recording
    startRecording();
    
    // Handle speech events
    currentUtterance.onstart = () => {
        playBtn.disabled = true;
        pauseBtn.disabled = false;
        stopBtn.disabled = false;
        showNotification('Recording speech...');
    };
    currentUtterance.onend = () => {
        stopRecording();
    };
    currentUtterance.onerror = (event) => {
        stopRecording();
        showNotification('Error in speech synthesis: ' + event.error, 'error');
    };
    speechSynthesis.speak(currentUtterance);
});
// Pause speech
pauseBtn.addEventListener('click', () => {
    if (speechSynthesis.speaking) {
        speechSynthesis.pause();
        playBtn.disabled = false;
        pauseBtn.disabled = true;
        showNotification('Speech paused');
    }
});
// Stop speech
stopBtn.addEventListener('click', () => {
    if (speechSynthesis.speaking || speechSynthesis.paused) {
        speechSynthesis.cancel();
        stopRecording();
        playBtn.disabled = false;
        pauseBtn.disabled = true;
        stopBtn.disabled = true;
        showNotification('Speech stopped');
    }
});
// Language selection
languageSelect.addEventListener('change', () => {
    const selectedLanguage = languageSelect.value;
    if (selectedLanguage) {
        // Find exact match first
        let matchingVoice = voices.find(voice => voice.lang === selectedLanguage);
        
        // If no exact match, try partial match
        if (!matchingVoice) {
            const langCode = selectedLanguage.split('-')[0];
            matchingVoice = voices.find(voice => voice.lang.startsWith(langCode));
        }
        
        if (matchingVoice) {
            voiceSelect.value = voices.indexOf(matchingVoice);
        }
    }
});
// Voice presets
const presets = {
    narration: { rate: 0.9, pitch: 0.8, volume: 1.0 },
    announcement: { rate: 1.2, pitch: 1.0, volume: 1.0 },
    conversational: { rate: 1.0, pitch: 1.1, volume: 0.9 },
    storytelling: { rate: 0.8, pitch: 1.2, volume: 1.0 }
};
presetBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        const preset = presets[btn.dataset.preset];
        if (preset) {
            rateSlider.value = preset.rate;
            pitchSlider.value = preset.pitch;
            volumeSlider.value = preset.volume;
            rateValue.textContent = preset.rate;
            pitchValue.textContent = preset.pitch;
            volumeValue.textContent = preset.volume;
            showNotification(`${btn.textContent.trim()} preset applied`);
        }
    });
});
// Download audio
downloadBtn.addEventListener('click', () => {
    if (!audioBlob) {
        showNotification('Please play speech first to generate audio', 'error');
        return;
    }
    
    const format = selectedFormat;
    let filename = `speech-${new Date().getTime()}`;
    
    // Convert audio format if needed
    if (format !== 'wav') {
        convertAudioFormat(audioBlob, format, selectedQuality, (convertedBlob) => {
            const url = URL.createObjectURL(convertedBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${filename}.${format}`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification(`${format.toUpperCase()} audio downloaded successfully!`);
        });
    } else {
        const url = URL.createObjectURL(audioBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${filename}.wav`;
        link.click();
        URL.revokeObjectURL(url);
        showNotification('WAV audio downloaded successfully!');
    }
});
// Audio recording functions
function startRecording() {
    audioChunks = [];
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
                audioStream = stream;
                mediaRecorder = new MediaRecorder(stream);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    downloadBtn.disabled = false;
                    showNotification('Audio ready for download!');
                };
                
                // Start recording when speech starts
                currentUtterance.onstart = () => {
                    playBtn.disabled = true;
                    pauseBtn.disabled = false;
                    stopBtn.disabled = false;
                    mediaRecorder.start();
                    showNotification('Recording speech...');
                };
                
                // Stop recording when speech ends
                currentUtterance.onend = () => {
                    mediaRecorder.stop();
                };
            })
            .catch(error => {
                console.error('Microphone access denied:', error);
                showNotification('Microphone access denied, using fallback method', 'error');
                setupSimpleDownload();
            });
    } else {
        console.error('getUserMedia not supported, using fallback method');
        showNotification('Audio recording not supported, using fallback method', 'error');
        setupSimpleDownload();
    }
}
function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }
    if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
        audioStream = null;
    }
}
// Convert audio format with quality settings
function convertAudioFormat(audioBlob, format, quality, callback) {
    // Use Web Audio API to decode and re-encode audio
    const reader = new FileReader();
    reader.onload = function(e) {
        audioContext.decodeAudioData(e.target.result)
            .then(decodedAudio => {
                // Create a new audio context for processing
                const offlineContext = new OfflineAudioContext(
                    decodedAudio.numberOfChannels,
                    decodedAudio.length,
                    decodedAudio.sampleRate
                );
                
                // Create a buffer source
                const source = offlineContext.createBufferSource();
                source.buffer = decodedAudio;
                source.connect(offlineContext.destination);
                source.start();
                
                // Render the audio
                offlineContext.startRendering()
                    .then(renderedBuffer => {
                        // Convert to WAV format
                        const wavBlob = bufferToWave(renderedBuffer, quality);
                        
                        // For other formats, we would need additional encoding
                        // This is a simplified approach
                        if (format === 'wav') {
                            callback(wavBlob);
                        } else {
                            // For demonstration, we'll just change the extension
                            // In a real app, you'd use a proper encoder
                            const simulatedBlob = new Blob([wavBlob], { type: `audio/${format}` });
                            callback(simulatedBlob);
                        }
                    })
                    .catch(error => {
                        console.error('Audio rendering failed:', error);
                        // Fallback to original blob with changed extension
                        const fallbackBlob = new Blob([audioBlob], { type: `audio/${format}` });
                        callback(fallbackBlob);
                    });
            })
            .catch(error => {
                console.error('Audio decoding failed:', error);
                // Fallback to original blob with changed extension
                const fallbackBlob = new Blob([audioBlob], { type: `audio/${format}` });
                callback(fallbackBlob);
            });
    };
    reader.readAsArrayBuffer(audioBlob);
}
// Helper function to convert AudioBuffer to WAV format
function bufferToWave(buffer, quality) {
    const numOfChan = buffer.numberOfChannels;
    const length = buffer.length * numOfChan * 2 + 44;
    const data = new Uint8Array(length);
    
    // Write WAV header
    writeString(data, 0, 'RIFF');
    writeUint32(data, 4, length - 8);
    writeString(data, 8, 'WAVE');
    writeString(data, 12, 'fmt ');
    writeUint32(data, 16, 16);
    writeUint16(data, 20, 1); // PCM format
    writeUint16(data, 22, numOfChan);
    writeUint32(data, 24, buffer.sampleRate);
    writeUint32(data, 28, buffer.sampleRate * 2 * numOfChan); // byte rate
    writeUint16(data, 32, numOfChan * 2); // block align
    writeUint16(data, 34, 16); // bits per sample
    writeString(data, 36, 'data');
    writeUint32(data, 40, length - 44);
    
    // Write audio data
    const offset = 44;
    for (let i = 0; i < buffer.numberOfChannels; i++) {
        const channel = buffer.getChannelData(i);
        let pos = offset + i * 2;
        for (let j = 0; j < channel.length; j++) {
            // Convert float32 to int16
            const sample = Math.max(-1, Math.min(1, channel[j]));
            const value = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
            writeInt16(data, pos, value);
            pos += 2;
        }
    }
    
    return new Blob([data], { type: 'audio/wav' });
}
function writeString(data, offset, string) {
    for (let i = 0; i < string.length; i++) {
        data[offset + i] = string.charCodeAt(i);
    }
}
function writeUint32(data, offset, value) {
    data[offset] = value & 0xff;
    data[offset + 1] = (value >> 8) & 0xff;
    data[offset + 2] = (value >> 16) & 0xff;
    data[offset + 3] = (value >> 24) & 0xff;
}
function writeUint16(data, offset, value) {
    data[offset] = value & 0xff;
    data[offset + 1] = (value >> 8) & 0xff;
}
function writeInt16(data, offset, value) {
    data[offset] = value & 0xff;
    data[offset + 1] = (value >> 8) & 0xff;
}
// Fallback download method
function setupSimpleDownload() {
    downloadBtn.addEventListener('click', () => {
        if (!textInput.value.trim()) {
            showNotification('Please enter some text to convert', 'error');
            return;
        }
        
        // Create a simple text file as fallback
        const textBlob = new Blob([textInput.value], { type: 'text/plain' });
        const url = URL.createObjectURL(textBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `speech-text-${new Date().getTime()}.txt`;
        link.click();
        URL.revokeObjectURL(url);
        showNotification('Text file downloaded as fallback', 'error');
    });
}
// Show notification
function showNotification(message, type = 'success') {
    notificationText.textContent = message;
    notification.style.backgroundColor = type === 'error' ? '#e74c3c' : '#2ecc71';
    notification.classList.add('show');
    setTimeout(() => {
        notification.classList.remove('show');
    }, 3000);
}
// Initialize
document.addEventListener('DOMContentLoaded', function() {
    createParticles();
    loadVoices();
    updateFormatInfo();
});
</script>
</body>
</html>
